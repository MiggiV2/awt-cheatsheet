\lstset{
  language=Java,
  morekeywords={function,const,let,var,return,import,export,default,from,useState,useEffect,useRef,useReducer,useContext,createContext,memo,useCallback,props,children}
}
\begin{center}
    {\Huge \textbf{React}}
\end{center}
\begin{multicols*}{3}

% =========================================================
\section{React Overview}
\begin{itemize}
  \item React is an open source JS library for building SPAs; key ideas: components, declarative UI, virtual DOM, props + state, client-side routing via React Router .
  \item Component rerendering: when \texttt{state} changes, React calls the component function again to produce a new UI representation .
\end{itemize}

\subsection{Project Quickstart}
\begin{itemize}
  \item Create app: \texttt{npx create-react-app my-app} 
  \item Run dev server: \texttt{npm start} 
\end{itemize}

% =========================================================
\section{JSX Essentials}
\subsection{What is JSX?}
\begin{itemize}
  \item JSX lets you embed HTML-like markup in JavaScript and return it from components .
\end{itemize}

\subsection{JSX Rules (Exam Favorites)}
\begin{itemize}
  \item Return a single root element (or use a fragment \texttt{<>...</>}) .
  \item Close all tags (even if HTML would allow omission) .
  \item Most attributes are camelCase; \texttt{className} instead of \texttt{class} .
\end{itemize}

\begin{lstlisting}
// Fragment example:
function App() {
  return (
    <>
      <h1>My Todos</h1>
      <img src="todo-icon.png" />
    </>
  );
}
\end{lstlisting}

% =========================================================
\section{Components \& Props}
\subsection{Function Component}
\begin{lstlisting}
function Hello({ name }) {
  return <h2>Hello {name}</h2>;
}
\end{lstlisting}

\subsection{Props}
\begin{itemize}
  \item Props pass data from parent to child as attributes in JSX .
  \item Common pattern: destructuring props in the parameter list .
\end{itemize}

\begin{lstlisting}
function App() {
  return <Hello name="World" />;
}
\end{lstlisting}

\subsection{children Prop}
\begin{itemize}
  \item \texttt{children} is the content between opening/closing component tags, used for composition .
\end{itemize}

\begin{lstlisting}
function Box({ children }) {
  return <div className="box">{children}</div>;
}
// Usage: <Box><b>Hi</b></Box>
\end{lstlisting}

% =========================================================
\section{Lists \& Keys}
\begin{itemize}
  \item Use \texttt{map()} to transform arrays into lists of elements .
  \item Keys help React identify which items have changed/added/removed; must be unique among siblings .
\end{itemize}

\begin{lstlisting}
function UserList({ users }) {
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
\end{lstlisting}

% =========================================================
\section{State \& Events}
\subsection{useState}
\begin{itemize}
  \item \texttt{useState(initial)} returns \texttt{[value, setter]}; calling setter triggers rerender .
\end{itemize}

\begin{lstlisting}
import { useState } from "react";

function Counter() {
  const [count, setCount] = useState(0);
  const inc = () => setCount(count + 1);

  return (
    <div>
      <p>Count {count}</p>
      <button onClick={inc}>Increment</button>
    </div>
  );
}
\end{lstlisting}

\subsection{Updating arrays/objects}
\begin{itemize}
  \item Use immutable updates (create new arrays/objects) to ensure React notices changes; spread operator is common .
\end{itemize}

\begin{lstlisting}
setTodos([...todos, newTodo]);
setFieldState({ ...fieldState, className: "error" });
\end{lstlisting}

\subsection{Passing args to handlers}
\begin{itemize}
  \item Use arrow function wrappers to pass the item/value .
\end{itemize}

\begin{lstlisting}
<button onClick={() => handleDone(todo)}>done</button>
\end{lstlisting}

% =========================================================
\section{Forms (Controlled)}
\begin{itemize}
  \item Controlled input: value comes from state; onChange updates state .
\end{itemize}

\begin{lstlisting}
function AddTodoForm({ todos, setTodos }) {
  const [description, setDescription] = useState("");

  const handleAdd = (event) => {
    event.preventDefault(); // when using a <form> 
    const newTodo = {
      id: Date.now(),
      description,
      status: "open",
    };
    setTodos([...todos, newTodo]);
    setDescription("");
  };

  return (
    <form onSubmit={handleAdd}>
      <input
        value={description}
        onChange={(e) => setDescription(e.target.value)}
        placeholder="describe todo..."
      />
      <button type="submit">add</button>
    </form>
  );
}
\end{lstlisting}

% =========================================================
\section{Effects \& Refs}
\subsection{useEffect}
\begin{itemize}
  \item Use \texttt{useEffect} for async loading / side effects; common pattern: call fetch once (empty dependency list) .
  \item Calling async load directly inside render causes infinite rerenders; \texttt{useEffect} avoids that .
\end{itemize}

\begin{lstlisting}
useEffect(() => {
  async function fetchData() {
    const res = await fetch("/api/articles");
    const data = await res.json();
    setArticles(data);
  }
  fetchData();
}, []);
\end{lstlisting}

\subsection{useRef (DOM access)}
\begin{itemize}
  \item \texttt{useRef} stores a reference; DOM element is in \texttt{ref.current} .
  \item Example use: focus an input after data arrives and rerender happened .
\end{itemize}

\begin{lstlisting}
const inputRef = useRef(null);

useEffect(() => {
  inputRef.current?.focus();
}, [articles]);

return <input ref={inputRef} />;
\end{lstlisting}

% =========================================================
\section{Advanced State}
\subsection{useReducer}
\begin{itemize}
  \item Useful when logic/state becomes complex; central handler (reducer) processes actions .
  \item Syntax: \texttt{const [state, dispatch] = useReducer(reducer, initialState)} .
\end{itemize}

\begin{lstlisting}
function todosReducer(todos, action) {
  switch (action.type) {
    case "addTodo":
      return [...todos, action.todo];
    case "done":
      return todos.map(t =>
        t.id === action.todo.id ? { ...t, status: "closed" } : t
      );
    default:
      throw Error("Unknown action " + action.type);
  }
}

const [todos, dispatch] = useReducer(todosReducer, todosInit);

// usage:
dispatch({ type: "done", todo });
\end{lstlisting}

\subsection{Context (Global State)}
\begin{itemize}
  \item Avoid ``prop drilling'' by providing data via Context and consuming with \texttt{useContext} .
\end{itemize}

\begin{lstlisting}
const AuthContext = createContext(null);

function App() {
  const auth = { user: "alice" };
  return (
    <AuthContext.Provider value={auth}>
      <Dashboard />
    </AuthContext.Provider>
  );
}

function Dashboard() {
  const auth = useContext(AuthContext);
  return <p>User: {auth.user}</p>;
}
\end{lstlisting}

% =========================================================
\section{Performance}
\subsection{Problem: Unnecessary rerenders}
\begin{itemize}
  \item If a parent rerenders, new function references can cause child rerenders even when data didn't change .
\end{itemize}

\subsection{memo + useCallback}
\begin{itemize}
  \item \texttt{memo(Component)}: rerender child only if props changed .
  \item \texttt{useCallback(fn, deps)}: keep function reference stable between renders .
  \item Use only when needed; adds complexity .
\end{itemize}

\begin{lstlisting}
const Todos = memo(function Todos({ todos, addTodo }) {
  return todos.map(t => <div key={t.id}>{t.description}</div>);
});

const addTodo = useCallback(() => {
  setTodos(t => [...t, { id: Date.now(), description: "New", status: "open" }]);
}, []);
\end{lstlisting}

% =========================================================
\section{React Router (Basics)}
\begin{itemize}
  \item React Router is provided by \texttt{react-router-dom} and enables client-side routing in SPAs .
\end{itemize}

\begin{lstlisting}
// Typical pattern (v6 style, simplified):
import { BrowserRouter, Routes, Route, Link } from "react-router-dom";

function App() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/contact">Contact</Link>
      </nav>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/contact" element={<Contact />} />
      </Routes>
    </BrowserRouter>
  );
}
\end{lstlisting}

% =========================================================
\section{Exam Pitfalls}
\begin{itemize}
  \item Mutating state directly (e.g., \texttt{todo.status = "closed"}) may not rerender; set new state immutably .
  \item Missing \texttt{key} in lists hurts correctness/performance; set stable keys in \texttt{map} .
  \item useEffect dependencies: empty \texttt{[]} means ``run once''; missing deps can cause stale values or extra calls .
  \item For \texttt{<form>}, use \texttt{event.preventDefault()} to prevent page reload on submit .
\end{itemize}

\end{multicols*}
